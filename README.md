## データ構造とアルゴリズム
- 計算量（Complexity）とは、**「入力データの量に対して、どれくらいの時間やメモリを消費するか」**を評価するための指標です。

## 計算量の2つの側面
- 計算量には、主に以下の2種類があります。
  - 時間計算量 (Time Complexity): 処理が終わるまでにどれだけのステップ（計算）が必要か。
  - 空間計算量 (Space Complexity): 実行中にどれだけのメモリ領域が必要か。

## ビッグオー（Big O）記法の基本
- 計算量を表すときには $O$ (オーダー)記法 を使います。これは「データの数 $n$ が無限に増えたとき、最悪どれくらいの時間がかかるか」を示します。

### 代表的な計算量一覧

| 計算量 | 名称 | データ量 $n$ に対する挙動 | 具体的な例 |
| :--- | :--- | :--- | :--- |
| **$O(1)$** | 定数時間 | データ量に関わらず常に一定。 | リストの要素アクセス、辞書のキー検索 |
| **$O(\log n)$** | 対数時間 | データが倍になっても、計算の手間は一歩増える程度。 | 二分探索 (Binary Search) |
| **$O(n)$** | 線形時間 | データ量に比例して計算量も増える。 | 1重の `for` ループによる走査 |
| **$O(n \log n)$** | 線形対数時間 | データ量に比例するより少し重い。 | 効率的なソート（Pythonの `sort()` など） |
| **$O(n^2)$** | 二乗時間 | データが2倍になると計算量は4倍になる。 | 二重の `for` ループ、バブルソート |
| **$O(2^n)$** | 指数時間 | データが少し増えるだけで爆発的に増える。 | 単純な再帰によるフィボナッチ数列 |
| **$O(n!)$** | 階乗時間 | 極めて遅く、実用的な計算は困難。 | 巡回セールスマン問題の全探索 |

---

### 計算量を見積もる際のポイント

1. **最悪のケースを想定する**:
   アルゴリズムが最も時間を要する場合（最悪時間計算量）を基準に評価します。
2. **定数項は無視する**:
   $O(2n)$ や $O(100n)$ は、すべて **$O(n)$** として扱います。
3. **最も影響の大きい項を残す**:
   $n^2 + n$ のような式の場合、最も増え方が大きい **$O(n^2)$** だけを計算量として表記します。
